{ lib, pkgs }:

let
  # Discover all subcommands by scanning the cmd directory
  # Returns a list of { name, description } attrsets
  discoverSubcommands =
    cmdDir:
    let
      # List all directories in cmd/
      entries = builtins.readDir cmdDir;

      # Filter to only directories (not README.md)
      subdirs = lib.filterAttrs (name: type: type == "directory") entries;

      # Convert to list of command names
      commandNames = lib.attrNames subdirs;

      # Try to extract description from each command's .go file
      getDescription =
        cmdName:
        let
          # Look for the main .go file (usually named after the command)
          goFile = "${cmdDir}/${cmdName}/${cmdName}.go";

          # Read the file if it exists
          content = if builtins.pathExists goFile then builtins.readFile goFile else "";

          # Extract comment with "Description:" pattern
          # This is a simple heuristic - could be improved
          lines = lib.splitString "\n" content;
          descriptionLines = builtins.filter (line: lib.hasInfix "Description:" line) lines;

          extractedDesc =
            if descriptionLines != [ ] then
              lib.removePrefix "// Description: " (builtins.head descriptionLines)
            else
              null;
        in
        extractedDesc;

      # Map command names to records with descriptions
      commands = map (name: {
        inherit name;
        description = getDescription name;
      }) commandNames;

      # Sort alphabetically
      sortedCommands = lib.sort (a: b: a.name < b.name) commands;
    in
    sortedCommands;

  # Generate import statements
  generateImports =
    commands:
    let
      importLines = map (cmd: "\t\"grit/cmd/${cmd.name}\"") commands;
    in
    lib.concatStringsSep "\n" importLines;

  # Generate switch cases
  generateCases =
    commands:
    let
      caseTemplate = cmd: ''
        	case "${cmd.name}":
        		${cmd.name}Cmd := flag.NewFlagSet("${cmd.name}", flag.ExitOnError)
        		${cmd.name}.RegisterFlags(${cmd.name}Cmd)
        		${cmd.name}Cmd.Parse(os.Args[2:])
        		${cmd.name}.Execute()'';

      cases = map caseTemplate commands;
    in
    lib.concatStringsSep "\n" cases;

  # Generate usage command list
  generateUsageCommands =
    commands:
    let
      # Determine padding for alignment
      maxNameLen = lib.foldl' (
        max: cmd: if lib.stringLength cmd.name > max then lib.stringLength cmd.name else max
      ) 0 commands;

      # Pad command name to align descriptions
      padName =
        name:
        let
          len = lib.stringLength name;
          padding = lib.concatStrings (lib.genList (_: " ") (maxNameLen - len + 2));
        in
        name + padding;

      commandLine =
        cmd:
        let
          desc = if cmd.description != null then cmd.description else ""; # No description available
        in
        "  ${padName cmd.name}${desc}";

      lines = map commandLine commands;
    in
    lib.concatStringsSep "\n" lines;

  # Main generator function
  generateMainGo =
    cmdDir:
    let
      commands = discoverSubcommands cmdDir;
      imports = generateImports commands;
      cases = generateCases commands;
      usageCommands = generateUsageCommands commands;
    in
    ''
      // This file is automatically generated by nix/gen-main.nix
      // DO NOT EDIT MANUALLY - your changes will be overwritten

      package main

      import (
      	"flag"
      	"fmt"
      	"os"

      ${imports}
      )

      func main() {
      	if len(os.Args) < 2 {
      		printUsage()
      		os.Exit(1)
      	}

      	// Get the subcommand
      	subcommand := os.Args[1]

      	switch subcommand {
      ${cases}
      	case "help", "-h", "--help":
      		printUsage()
      		os.Exit(0)
      	default:
      		fmt.Fprintf(os.Stderr, "Unknown subcommand: %s\n\n", subcommand)
      		printUsage()
      		os.Exit(1)
      	}
      }

      func printUsage() {
      	fmt.Fprintf(os.Stderr, `grit - A pipeline execution tool

      Usage:
        grit <command> [options]

      Commands:
      ${usageCommands}

      Use "grit <command> -h" for more information about a command.
      `)
      }
    '';
in
{
  inherit discoverSubcommands generateMainGo;

  # Helper to write main.go to a derivation
  writeMainGo =
    cmdDir:
    pkgs.writeTextFile {
      name = "main.go";
      text = generateMainGo cmdDir;
    };
}
